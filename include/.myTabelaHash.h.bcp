#ifndef HASH_TBL_H
#define HASH_TBL_H

#include "natalia.h"

namespace MyHashTable {

    //! Hash table entry.
    /*! This class is used to make it easier to manipulate hash table entries, by handling an entry as a pair of \a key + \a data.
     * \tparam KeyType   Type definition for the key used to access the hash table
     * \tparam DataType  Type definition for the data to be stored in the hash table
     */
    template< class KeyType, class DataType >
    class HashEntry {
        public:
            //! Simple constructor.
            /*! \param _key Entry key.
             *  \param _data Data item.
             */
            //Alterado pra inicializar o construtor caso nenhum parametro seja passado
            HashEntry ( KeyType _key = KeyType() , DataType _data = DataType() ) : mKey( _key ), mData( _data ) { /* Empty */ };
            //HashEntry ( KeyType _key , DataType _data ) : mKey( _key ), mData( _data ) { /* Empty */ };
            //~HashEntry ( ) { mKey.~KeyType(); mData.~DataType(); }
            KeyType mKey;   /*!< Stores the key for an entry. */
            DataType mData; /*!< Stores the data for an entry. */
    };


    //! A simple hash table.
    /*! This class represents a hash table that uses double hasing and the external liking method to handle collisions.
     *  The external (and independent) hash funcion must be specified by the client code.
     *  Internaly, this class uses the \a division \a method to map keys to data table entries.
     *  \tparam KeyType   Type definition for the key used to access the hash table
     *  \tparam DataType  Type definition for the data to be stored in the hash table
     *  \tparam KeyHash   Function object to provide a hash value given a key.
     *  \tparam KeyEqual  Function object to compara keys types.
     */
    template < typename KeyType,
               typename DataType,
               typename KeyHash  = std::hash<KeyType>,
               typename KeyEqual = std::equal_to<KeyType> >
    class HashTbl
    {
        public:
            //! It is used to make code more concise.
            using Entry = HashEntry< KeyType, DataType >;

            HashTbl ( int _initTableSize = DEFAULT_SIZE );
            virtual ~HashTbl ();

            bool insert ( const KeyType &, const DataType & ) throw ( std::bad_alloc );
            bool remove ( const KeyType & );
            bool retrieve ( const KeyType &, DataType & ) const;
            void clear ( void );
            bool isEmpty ( void ) const;
            unsigned long int count ( void ) const;

            void showStructure () const;
            
       private:
           //! Disable copy constructor (we don't need it in this implementation).
           HashTbl( const HashTbl& );
           //! Assignment method is also disabled.
           const HashTbl & operator= ( const HashTbl & );

       private:
            //! Rehash
           void rehash( void );
           //! Hash table size.
           unsigned int mSize;             
           //! Number of element currently stored in the table.
           unsigned int mCount;                     
           //! Actual data strucure, corresponding to a table of collision list for elements.
           std::unique_ptr< FWRDLIST< Entry > [] > mpDataTable;

           //! Hash table's default size: 10 table entries.
           static const short DEFAULT_SIZE = 11;     
           
           bool is_prime(unsigned int _num); // Checa se o número passado é primos
    };

} // namespace MyHashTable

//! MyHashTable namespace encapsulates all class related to a simple hash function definition.
namespace MyHashTable {

    //----------------------------------------------------------------------------------------
    //! Default construtor.
    /*! Creates a hash table of the required capacity, which uses an external hash function
     *  that maps keys to unsigned long integers.
     *  If no external hash function is provided, an \r UndefinedHashFunctionException is generated.
     *  \param _initSize Required hash table capacity.
     *  \param _pfHF Pointer to an external hash function that does the first hashing and returns an unsigned long int.
     *  \throw UndefinedHashFunctionException if no external hash function is provided.
    */
    template < typename KeyType, typename DataType, typename KeyHash, typename KeyEqual >
    HashTbl< KeyType, DataType, KeyHash, KeyEqual >::HashTbl ( int _initSize )
        : mSize( _initSize ), mCount( 0u )
    {
        
        if( mSize != 11 ){ // Funçao pra saber qual o menor primo maior que o _initSize;
            while(!is_prime(++ mSize));
        }
            // Tenta alocar vector que guarda as listas encadeadas
            try{
                //Aloca o array de listas encadeadas
                mpDataTable.reset( new FWRDLIST<Entry>[mSize] );
            }catch (std::bad_alloc & error){
                // Se ocorrer algum erro, imprima uma mensagem
                std::cerr << "ERROR>>> In constructor HashTbl() " << std::endl;
            }
    }
    
    template < typename KeyType, typename DataType, typename KeyHash, typename KeyEqual >
    bool HashTbl< KeyType, DataType, KeyHash, KeyEqual >::is_prime(unsigned int _num){
        std::size_t b = 2; // O outro número que vai ser usado no teste
        while( b <= sqrt(_num) && _num % b != 0){ // Se o número passado não poder ser divisível
            b++; // Incremente o segundo
        }
        if (_num % b == 0) return false;  // Se os números não forem primos entre sí, retorne false
        return true;
    }
    
    //----------------------------------------------------------------------------------------
    //! Destrutor that just frees the table memory, clearing all collision lists.
    template < typename KeyType, typename DataType, typename KeyHash, typename KeyEqual >
    HashTbl< KeyType, DataType, KeyHash, KeyEqual >::~HashTbl ()
    {
        for(int i = 0; i < mCount; i++){
            (mpDataTable.get() + i)->clear(); // Apaga todas as listas encadeadas
        }
        mCount = 0;
        mSize = 0;
    }

    //----------------------------------------------------------------------------------------
    //! Inserts data into the hash table.
    /*! For an insertion to occur, the client code should provide a key and the data itself
     *  If the data is already stored in the table, the function updates the data with the
     *  new information provided.
     *  \param _newKey Key associated with the data, used to get to the stored information.
     *  \param _newDataItem Data to be stored or updated, in case the information is already stored in the hash table.
     *  \return true if the data is already stored in the table and it is updated; false, otherwise.
     *  \throw std::bad_alloc In case no memory is available for dynamic allocation required in the insertion procedure.
    */
    template < typename KeyType, typename DataType, typename KeyHash, typename KeyEqual >
    bool HashTbl< KeyType, DataType, KeyHash, KeyEqual >::insert ( const KeyType & _newKey, const DataType & _newDataItem ) throw ( std::bad_alloc )
    {
        // Flag used to indicate whether the data has been found or not.
        auto bDataFound( false );
        KeyHash hashType; // Pega o tipo de hash a ser usado
        KeyEqual equalType; // Guarda o tipo de igualdade usada
        std::size_t end = (hashType(_newKey) % mSize); // Pega a posição do elemento que será inserido
        auto it = mpDataTable[end].begin(); // Iterator usado para pesquisar se o elemento já existe
        while(it != mpDataTable[end].end()){
            if(equalType((*it).mKey, _newKey)){ // Se já existir o elemento na lista
                (*it).mData = _newDataItem; // Sobrescreva o dado
                return bDataFound; // Retorna false
            }
            it ++;
        }
        
        // O rehash sempre é executado antes de inserir um novo elemento
        rehash();
        // Se o elemento não for encontrado, crie um novo elemento para ser inserido
        Entry _newEntry(_newKey, _newDataItem);
        // atualiza o end com o novo mSize.
        end = (hashType(_newKey) % mSize);
        // Adiciona o novo elemento na lista
        mpDataTable[end].push_front(_newEntry);
        
        bDataFound = true;
        
        mCount++; // Aumenta o contador de elementos
        
        return bDataFound;
        
    }

    template < typename KeyType, typename DataType, typename KeyHash, typename KeyEqual >
    void HashTbl< KeyType, DataType, KeyHash, KeyEqual >::rehash ( void )
    {
            
        if( mCount > mSize){
            //std::cout << "mCount > mSize\n";
            int originalSize = mSize; // Guarda o tamanho original do array
            mSize = mSize * 2;
            while(!is_prime(++ mSize)); // Pega o menor primo maior que o dobro do array
            std::unique_ptr< FWRDLIST<Entry> [] > backup ( new FWRDLIST<Entry>[originalSize] ); // Cria um backup
            for(auto i(0u); i < originalSize; i++){
                backup[i] = mpDataTable[i]; // Copia as FWRDLIST do mpDataTable para o backup
            }
            mpDataTable.reset( new FWRDLIST<Entry>[mSize] ); // Reinicia o mpDataTable com o novo tamanho
            mCount = 0; // Reinicia o mCount para 0.
            for(auto i(0u); i < originalSize; i++){
                auto it = backup[i].begin(); // Cria um iterator para percorrer todos os elementos da FWRDLIST
                while(it != backup[i].end()){
                    insert((*it).mKey, (*it).mData); // Re-insere os elementos na mpDataTable
                    it ++;
                }
            }
            //std::cout << "mCount is now " << mCount << " & mSize is now " << mSize << "\n";
        }
        //std::cout << "mCount is " << mCount << " & mSize is " << mSize << "\n";
    }

    //----------------------------------------------------------------------------------------
    //! Removes data from the hash table.
    /*! Removse a data item from the table, based on the key associated with the data.
     *  If the data cannot be found, false is returned; otherwise, true is returned instead.
     *  \param _searchKey Data key to search for in the table.
     *  \return true if the data item is found; false, otherwise.
    */
    template < typename KeyType, typename DataType, typename KeyHash, typename KeyEqual >
    bool HashTbl< KeyType, DataType, KeyHash, KeyEqual >::remove ( const KeyType & _searchKey )
    {
        // TODO
        KeyHash hashType; // Pega o tipo primário de hash passada
        KeyEqual equalType; // Guarda o tipo de igualdade que será usada
        std::size_t end = (hashType(_searchKey) % mSize); // Pega a posição do elemento que será removido
        auto it = mpDataTable[end].begin(); // Iterator usado para pesquisar o elemento na tabela
        auto before_it = mpDataTable[end].before_begin(); // Iterator usado para guardar a posição anterior ao it
        auto bRemoved( false );
        
        while(it != mpDataTable[end].end()){
            if(equalType((*it).mKey, _searchKey)){
                mpDataTable[end].erase_after(before_it); // Apaga o elemento encontrado
                bRemoved = true; // O elemento foi encontrado e removido
                mCount --; // Diminui em 1 a quantidade de elementos
                break;
            }
            before_it ++;
            it ++;
        }
        
        return bRemoved;
    }

    //----------------------------------------------------------------------------------------
    //! Retrieves data from the table.
    /*! Retrieves a data item from the table, based on the key associated with the data.
     *  If the data cannot be found, false is returned; otherwise, true is returned instead.
     *  \param _searchKey Data key to search for in the table.
     *  \param _dataItem Data record to be filled in when data item is found.
     *  \return true if the data item is found; false, otherwise.
    */
    template < typename KeyType, typename DataType, typename KeyHash, typename KeyEqual >
    bool HashTbl< KeyType, DataType, KeyHash, KeyEqual >::retrieve ( const KeyType & _searchKey, DataType & _dataItem ) const
    {
        KeyHash hashType; // Pega o tipo primário de hash passada
        KeyEqual equalType; // Guarda o tipo de igualdade que será usada
        std::size_t end = (hashType(_searchKey) % mSize); // Pega a posição do elemento que será retornado
        auto it = mpDataTable[end].begin(); // Iterator usado para pesquisar o elemento na tabela
        auto bFound( false );
        
        while(it != mpDataTable[end].end()){
            if(equalType((*it).mKey, _searchKey)){
                _dataItem = (*it).mData; // Guarda o elemento encontrado
                bFound = true; // O elemento foi encontrado
            }
            it ++;
        }
        
        return bFound;
    }

    //! Clears the data table.
    template < typename KeyType, typename DataType, typename KeyHash, typename KeyEqual >
    void HashTbl< KeyType, DataType, KeyHash, KeyEqual >::clear ()
    {
        for(auto i(0u); i < mSize; i++){
            mpDataTable[i].clear();
        }
        mCount = 0;
    }

    //! Tests whether the table is empty.
    /*!
     * \return true is table is empty, false otherwise.
     */
    template < typename KeyType, typename DataType, typename KeyHash, typename KeyEqual >
    bool HashTbl< KeyType, DataType, KeyHash, KeyEqual >::isEmpty () const
    {
        return ( mCount == 0 );
    }

    //! Counts the number of elements currently stored in the table.
    /*!
     * \return The current number of elements in the table.
     */
    template < typename KeyType, typename DataType, typename KeyHash, typename KeyEqual >
    unsigned long int HashTbl< KeyType, DataType, KeyHash, KeyEqual >::count () const
    {
        return mCount;
    }

    //! Prints out the hash table content.
    template < typename KeyType, typename DataType, typename KeyHash, typename KeyEqual >
    void HashTbl< KeyType, DataType, KeyHash, KeyEqual >::showStructure () const
    {
        KeyHash hashFn;

        // Traverse the list associated with the based address (idx), calculated before.
        for( auto i(0) ; i < mSize; ++i )
        {
            std::cout << i << " :{ key=";
            for( auto & e : mpDataTable[ i ] )
            {
                std::cout << hashFn( e.mKey ) << " ;\n   " << e.mData << " " ;
            }
            std::cout << "}\n";
        }
    }

} // namespace MyHashTable


#endif